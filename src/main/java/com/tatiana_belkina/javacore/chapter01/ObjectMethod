package java.lang;

public class Object {

*********************************************************
 1.   public final native Class<?> getClass();
*********************************************************
// getClass() возвращает ссылку на метаобъект типа класс.
// С его помощью можно получать информацию о классе,
// к которому принадлежит объект.



*******************************************************************************
 2.   protected native Object clone() throws CloneNotSupportedException;
******************************************************************************
// https://habr.com/ru/post/246993/
// Иногда необходимо получить копию объекта, которая не зависела бы
// от оригинала. С которой можно было бы производить манипуляции,
// при этом, не изменяя оригинал. При обыкновенном присваивание объектов
// (obj1 = obj2;) передаются ссылки на объект. В итоге два экземпляра ссылаются
// на один объект, и изменение одного приведет к изменению другого.
// нам на помощь придет интерфейс Cloneable и метод clone() класса Object.
//если нам необходимо получить независимый клон объекта,
// то необходимо вызвать метод clone().
// Данный метод объявлен, как protected, а это значит, что метод защищен,
// и может быть доступен только при наследовании объекта.
// Как выясняется, это не является проблемой, потому как любой класс,
// является потомком класса Object. Однако при защищенном методе
// класс может клонировать только свои собственные объекты.
// Чтобы клонировать другие объекты,
// метод clone() необходимо расширить до public.
// public User clone() throws CloneNotSupportedException {
                return (User)super.clone();}
// Как мы можем видеть метод clone() может выбрасывать исключение
// CloneNotSupportedException. Данное исключение возникает в случае,
// когда клонируемый класс не имеет реализации интерфейса Cloneable.
// Интерфейс Cloneable не реализует ни одного метода.
// Он является всего лишь маркером, говорящим, что данный класс
// реализует клонирование объекта. Само клонирование осуществляется вызовом
// родительского метода clone().
// Данный вид клонирования называется поверхностным клонированием.
// Его можно использовать только в том случае,
// если у клонируемого класса объявлены  неизменяемые поля-примитивы.
// Существует так же второй вид клонирования объекта,
// который называется глубокое клонирование. Его используют в тех случаях,
// когда в клонируемом классе есть изменяемые объекты (ссылки).
// public User clone() throws CloneNotSupportedException {
                User clone = (User)super.clone();
                clone.birthday = (GregorianCalendar) birthday.clone();
                return clone;}
// clone.birthday = (GregorianCalendar) birthday.clone();
// напрямую клонируется поле birthday

По соглашению, метод clone() должен возвращать объект независимый
от клонируемого объекта, но механизм работы метода clone() класса Object
не предоставляет возможности получить полностью клонированый обьект
для любого класса. Он возвращает лишь поверхностную копию, а далее,
работа по глубокому клонированию возлагается на разработчика.
Проще говоря, если у "оригинала" есть поле которое содержит ссылку
на какой-то обьект, то и поле клона будет ссылаться на тот же обьект,
а это противоречит соглашению о независимости клонируемых обьектов.
В таком случае, необходимо для всех изменяемых обьектов либо вызывать clone() (если это возможно) либо создавать новые с таким же сосотянием. И, насколько я понимаю, чтобы избежать "слепое клонирование" авторами языка были введены следующие ограничения:
 - метод clone() обьявлен как protected (исключает возможность вызова
 прямо на обьекте)
 - клонируемый класс должен реализовывать интерфейс Cloneable
Интерфейс Cloneable не содержит в себе ни одного метода и
является по сути "маркером" того, что обьект может быть клонирован,
без него, при попытке клонирования будет выброшен CloneNotSupportedException.
Перед тем как обьявлять свой класс как Cloneable, следует внимательно
проанализировать его структуру, и определить какие поля нужно
проинициализировать после выполнения super.clone().



******************************************************************************
3.    public native int hashCode();
******************************************************************************
public static void main(String[] args) {
		Object object = new Object();
		int hCode;
		hCode = object.hashCode();
		System.out.println(hCode);
	}

	1389133897 - пример вывода int
	function от hash — «превращать в фарш», «мешанина»[1]),
	или функция свёртки — функция, осуществляющая преобразование массива
	входных данных произвольной длины в (выходную) битовую строку
	установленной длины, выполняемое определённым алгоритмом.
	хеш-код это число, у которого есть свой предел,
	который для java ограничен примитивным целочисленным типом int
	от -2_147_483_648 до 2_147_483_647
	В итоге, в терминах Java, хеш-код — это целочисленный
	результат работы метода, которому в качестве входного параметра
	передан объект. хеш-код вычисляется на основании содержимого объекта (значения полей)
	Хэш-кодом называется условно уникальный числовой идентификатор,
	сопоставляемый какому-либо элементу. Из соображений безопасности выдавать адрес объекта
	прикладной программе нельзя. Поэтому в Java хэш-код заменяет адрес объекта в тех случаях,
	когда для каких-либо целей надо хранить таблицы адресов объектов.
	Здесь главное понять, что:
    Если хеш-коды разные, то и входные объекты гарантированно разные.
    Если хеш-коды равны, то входные объекты не всегда равны.

    Ситуация, когда у разных объектов одинаковые хеш-коды называется
    — коллизией. Вероятность возникновения коллизии
    зависит от используемого алгоритма генерации хеш-кода.
    Хеш-код это число, идентифицирующее обьект,
    поэтому при вычислении хеш-кода следует выбирать уникальные
    и не изменяющиеся во время жизни обьекта поля

    Переопределение метода
    @Override
    	public int hashCode() {
    		final int prime = 31;
    		int result = 1;
    		result = prime * result + varA;
    		result = prime * result + varB;
    		return result;
    	}

****************************************************************************
    public boolean equals(Object obj) {
        return (this == obj);
    }
****************************************************************************
При сравнение объектов, операция “==” вернет true лишь в одном случае
— когда ссылки указывают на один и тот-же объект.
В данном случае не учитывается содержимое полей.
Указывает, равен ли какой-либо другой объект этому объекту.

Метод equals реализует отношение эквивалентности для ненулевых ссылок на объекты:

Оно рефлексивно: для любого ненулевого ссылочного значения x, x.equals(x) должно возвращать true.
Оно симметрично: для любых ненулевых ссылочных значений x и y x.equals(y) должен возвращать true,
только если y.equals(x) возвращает true.
Оно транзитивно: для любых ненулевых ссылочных значений x, y и z, если x.equals(y) возвращает true,
а y.equals(z) возвращает true, тогда x.equals(z) должен возвращать true.
Оно непротиворечиво (консистентно): для любых ненулевых ссылочных значений x и y
множественные вызовы x.equals(y) последовательно возвращают true или последовательно
возвращают false при условии, что никакая информация, используемая в сравнениях equals на объектах,
не изменяется.
Для любого ненулевого ссылочного значения x, x.equals(null) должен возвращать false.
Необходимо переопределять метод hashCode всякий раз, когда метод equals переопределяется,
чтобы поддерживать общий контракт для метода hashCode,
в котором говорится, что равные объекты должны иметь одинаковые хэш-коды.
 public boolean equals(Object obj) {// class Man - example
        if (this == obj) return true;
        if (obj == null || obj.getClass() != getClass()) return false;
        Man man == (Man)obj;
        return dnaCode == man.dnaCode;
    }

****************************************************************************
    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
 ***************************************************************************
Возвращает строковое представление объекта.
В общем случае метод toString возвращает строку, которая является
"текстовым представлением" этого объекта. Результатом должно быть краткое,
но информативное представление, которое легко читается человеком. Рекомендуется,
чтобы все подклассы переопределяли этот метод.
Метод toString для класса Object возвращает строку, состоящую из имени класса,
экземпляром которого является объект, символа знака "@" и
шестнадцатеричного представления без знака хэш-кода объекта.
Другими словами, этот метод возвращает строку, равную значению:

getClass().getName() + '@' + Integer.toHexString(hashCode())
Java Object.toString ()также использует шестнадцатеричное представление
того, что фактически является его хэш-кодом идентичности .
В большинстве стандартных классов этот метод переопределен.
Для числовых классов возвращается строковое представление числа,
для строковых – содержимое строки,
для символьного – сам символ (а не строковое представление его кода!).


***************************************************************
    protected void finalize() throws Throwable { }
***************************************************************
Метод, который будет вызываться непосредственно перед окончательным
уничтожением объекта сборщиком мусора. (финализатором).
В Java finalize() может быть использован для обеспечения чистого завершения
объекта. К примеру, мы можете использовать finalize() чтобы
удостовериться в том, что открытый файл, принадлежащий данному объекту,
был закрыт. Для добавления финализатора в класс, вам просто следует
определить метод finalize() в Java. Среда выполнения Java производит
вызов данного метода непосредственно перед обработкой объекта данного класса.
В составе метода finalize(), вы указываете те действия,
которые должны быть выполнены перед уничтожением объекта.
Ключевое слово protected представляет спецификатор,
предотвращающий доступ к finalize() посредством кода,
определяемого вне его класса.
Это свидетельствует о том, что вы не можете знать как или
даже когда будет производиться выполнение finalize(). К примеру,
если ваша программа будет окончена до «сборки мусора»,
finalize() не будет выполняться.



****************************************************************************************
    private static native void registerNatives();
******************************************************************************
        static {
            registerNatives();
        }

    public final native void notify();

    public final native void notifyAll();

    public final native void wait(long timeout) throws InterruptedException;

    public final void wait(long timeout, int nanos) throws InterruptedException {
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }

        if (nanos >= 500000 || (nanos != 0 && timeout == 0)) {
            timeout++;
        }

        wait(timeout);
    }

    public final void wait() throws InterruptedException {
        wait(0);
    }


}








"Любая техническая система должна быть идиотоустойчивой" (с)