Шилдт Г. Java 8. Полное руководство 9-е издание.

1. Парадигма ООП
Подход к программированию при котором программа представляется
в виде совокупности объектов, каждый из которых является экземпляром
класса,а классы образуют иерархию наследования.

2. Отличительные особенности Java :
Простота
Безопасность
Переносимость
Архитектурная нейтральность
Надежность
Многопоточность
Распределенность
Динамичность

Безопасность и переносимость программы обеспечивает главная особенность
Java - байткод -оптимизированный набор инструкций, предназначенных для
выполнения в исполняющей среде Java.

3. JRE - Java Runtime Environment состоит из
JVM - Java Virtual Machine и библиотек Java классов.
JRE входит в Java Development Kit -комплект разработчика, в составе которого:
 javac - компилятор исходного кода в байткод.
 стандартные библиотеки классов, документация, утилиты, примеры.

4. JVM состоит из трех основных частей:
Java HotSpot Virtual Machine Runtime
JIT compile (Just in Time)
Garbage Collector

JVM первоначально задумывалась как интерпретатор байткода, вскоре появилачь
технология HotSpot, позволяющая компилировать избранные части кода в реальном
времени и по требованию. Компилируются не все части кода, только те, которым
компиляция принесет выгоду, остальные части интерпретируются. Так же JVM
анализирует часто используемые части кода и собирает статистику их использования,
на основе которой перекомпилирует этот код в более производительный.

Garbage Collector - уборщик мусора. Программа, которая автоматически удаляет
объекты, на которые не осталось ссылок.

4. Абстракция. Важный элемент ООП. Это набор наиболее важных характеристик
объекта, которых с достаточной точностью представляют его в системе.
Это процесс сокрытия деталей реализации от пользователя, предоставляя ему
только функционал. В Java абстракция достигается с использованием
абстрактных классов и интерфейсов.

5. Три принципа ООП.
Инкапсуляция - механизм, связывающий код и данные, которыми он манипулирует.
Защитная оболочка, которая предохраняет код и данные от произвольного
доступа. Класс - основа инкапсуляции.

Наследование - процесс, в результате которого один класс получает
свойства другого. Наследование обеспечивает принцип иерархической
классификации.

Полиморфизм - принцип, позволяющий использовать один интерфейс для
общего класса действий. Один интерфейс - много методов. Выбор конкретного
метода входит в обязанности компилятора.

6. Компиляция программы.
C:\> javac Example.java
компилятор создаст файл с байткодом Example.class. В процессе компиляции
каждый отдельный класс программы помещается в собственный выходной файл.
Для выполнения программы используется загрузчик классов java
C:\> java Example
Загрузчик приложений будет автоматически искать файл с указанным именем
и расширением .class.

7. Метод main вызывается JVM перед созданием любых объектов.
Параметр методы принимает аргументы командной строки.
Аргументы командной строки - это информация, которая во время запуска
программы указывается в командной строке непосредственно после
имени программы.
Для передачи значения в метод нужно написать в командной строке полное
название класса с пакетом и следом аргументы, через пробел.
java.com.company.lesson2.MyFirst значение1 значение2

8. Переменная - именованная ячейка памяти, которой может быть
присвоено значение в программе. 3 типа переменных:

Переменная класса - глобальная переменная с модификатором static.
При создании объектов класса копии этих переменных не создаются.
Все экземпляры класса совместно используют эти переменные.


Переменная экземпляра - переменная, которая объявляется в классе
за пределами метода, конструктора или блока. Эти переменные создаются
при создании объекта (ключевое слово New), тогда  в стеке создается
слот для каждого значения переменной экземпляра.
Удаляются с удалением объекта.
Переменные экземпляра имеют значения по умолчанию:
Для чисел по умолчанию 0;
Для логических переменных false;
Для объектов null.

Локальная переменная объявляются и инициализируются в методах,
конструкторах или блоках и уничтожаются как завершается метод, конструктор
или блок. Значений по умолчанию и модификаторов не существует,
видимость в пределах блока. Реализуются в стеке.

9. Оператор if (логическое выражение){ блок кода }
else {блок кода};

Цикл for(инициализация переменной; логическое выражение; итерация)
{блок кода};
В первом и третьем параметрах через запятую можно указывать
несколько переменных.
Цикл For each.
int[] array = new int{1, 2, 3}
for(int x : array) {
System.out.println(x);
}

10. В Java идентификатором переменной, метода, класса может быть
любая последовательность строчных и прописных букв, цифр, символа
подчеркивания или денежной единицы. Знак $ не предназначен для
общего использования.
Идентификаторы не должны начинаться с цифры. Начиная с версии JDK 8,
знак _ не рекомендуется употреблять в качестве идентификатора.

11. Литералы пробелы, ключевые слова
В Java постоянное значение указывается в качестве литерала
целочисленное значение 1, 2,
число с плавающей точкой 1.2, 4.25,
символьная константа 'W',
строковое значение "This is a test"

В целочисленных литералах  могут использоваться  как десятичные значения
так и числа по двоичному (с JDK 7 ), восьмеричному и шестнадцатеричному
основаниям.
двоичные литералы с префиксом 0B или 0b,
восьмеричные литералы начинаются с 0 и до 7,
шестнадцатеричные литералы начинаются с префикса 0X или 0x.
Разрешается использовать без префикса числа до 16.
Создаются используя символы [0-9 a-f A-F].

Логические литералы. Boolean/
false true
true не равен 1 , false не равен 0.


Символьные литералы.
В коде ACII можно выводить непосредственно, заключая в одинарные
кавычки 'a'.
Для ввода значений в восьмеричной форме применяют \ а следом
трехзначное число /141 равно 'a'.
Для ввода значений в шестнадцатеричной форме применяют \u а следом
четыре шестнадцатеричные цифры /u0061 равно 'a'.
Если символ нельзя ввести непосредственно используется ряд
управляющих последовательностей, например символ ' -  /'
через знак косой черты.


Пробелами считаются символы пробела, табуляции и новой строки.
50 ключевых слов, которые нельзя использовать в качестве идентификатора,
а также false, true, null.
С точки зрения компилятора основная роль пробелов и комментариев служить
разделителями между лексемами, далее разделители отбрасываются и
на скомпилированный код не влияют.
Лексема (tokens) - элементарная конструкция языка, из которой компилятор
javac генерирует исполняемый байткод.
идентификаторы,
ключевые слова,
литералы,
разделители,
операторы.

12. Комментарии.
//               однострочный комментарий
/*            */ многострочный комментарий
/**           */ документирующий комментарий



13. Библиотеки классов.
Виртуальная библиотека протестированного кода, в которой
информация разбита по отдельно взятому направлению по пакетам.

14. Примитивные типы.
Java строго типизированный язык, каждая переменная, каждое
выражение имеет конкретный тип и каждый тип строго определен.
Все выражения и переменные проверяются компилятором на соответствие типов.
Любые несоответствия типов должны быть исправлены до завершения компиляции
класса.

Целочисленные типы:
byte - 8 бит или 1 байт, диапазон от -128 до 127;
short - 16 бит или 2 байта, диапазон от -32768 до 32767;
int   - 32 бита или 4 байта, диапазон от -2147843648 до 2147483647
                      или -2(в степени 31) степени до 2 (в степени 31) - 1
long  - 64 бита или 8 байт,
диапазон от -2(в степени 63) степени до 2 (в степени 63) - 1;
Чтобы обозначить литерал типа long, его следует дополнить L или l.

char символьный тип предназначен для хранения символов в Unicode
(полный набор символов на всех языках мира)/
Каждому символу соответствует определенное число из таблицы кодировки
UTF - 16
16 бит (2 байта) в Java, диапазон от 0 до 65536.
ASCII  от 0 до 127  или 1 байт
ISO Latin-1  от 0 до 255

числа с плавающей точкой:

float  - 32 бита или 4 байта, диапазон  1.4е-045 до 3.4е+038
по умолчанию 0.0f. 7 знаков после запятой.

double - 64 бита или 8 байт, диапазон  4.9е-324 до 1.8е+308
по умолчанию 0.0d. 16 знаков после запятой.

По умолчанию литералам с плавающей точкой присваивается тип double,
чтобы указать литерал типа float, его следует дополнить F или f.
Начиная с JDK 7, для удобства чтения литералов,в обозначении литерала
можно указывать один или более знаков _ .

логические значения:
тип boolean
true или false, по умолчанию значение false.
Размер зависит от определенной реализации JVM.
В стандартной реализации 32 бита или 4 байта, в определенных
версиях JVM в массиве каждое значение занимает по 1 биту.


15. Переменные.
Основная единица хранения данных. Переменные должны быть объявлены
до их использования. Любой переменной можно присвоить начальное
значение соответствующего типа - инициализировать ее.
int a;
double x, y, z;
Блок кода заключенный в { область действия }
переменные объявленные в области действия не доступны за
пределами этой области.
Параметры метода также входят в область действия метода.
Переменные создаются при входе в их область действия и уничтожаются
на выходе из нее.
Если объявление переменной включает ее инициализацию, то инициализация
будет повторятся каждый раз при входе в область, где она объявлена.

16. Преобразование и приведение типов.
Когда данные одного типа присваиваются переменной другого типа, то
преобразование происходит автоматмчески если:
оба типа совместимы
длина целевого типа больше длины исходного
При соблюдении этих условий происходит расширяющее не явное преобразование.
byte->short->int->long
float -> double
Не существует автоматического преобразования типов char и boolean.

Приведение типов.
Это явное преобразование типов.
Если длина целевого типа меньше длины исходного преобразование
будет сведено к результату деления по модулю (остаток от целочисленного
деления) исходного типа на диапазон целевого.
int a = 257;
byte b;
b = (byte)257;// b = 1

усечение дробной части происходит если в целочисленную переменную
поместить число с плавающей точкой.Если длина целочисленной части
числа с плавающей точкой не умещается в целевом целочисленном типе, то
преобразование будет сведено к результату деления по модулю числа с плавающей точкой на диапазон целевого типа.

17. Правила продвижения типов.
В выражениях тип типы byte, short, char автоматически продвигаются в int
float в double.
byte b = 50;
byte a = (byte)50 * 2;// необходимо явно привести к byte из за продвижения
к int во время вычисления выражения.
Если один из типов в выражении относится к типу long, все выражение затем
продвигается к типу long.
Если float к типу float, если double к типу double.
byte, short, char -> int->long->float->doble.

18. Массивы.
Это группа(структура данных) однотипных переменных, для обращения к которым используется
общее имя. Допускается создание массивов любого типа и размерности.
int[] array = new int[10];
int[] array = {1, 3, 45, 25, 100};
Доступ к массиву осуществляется по его индексу array[2];
Индексы массивов начинаются с 0.
Длина массива  array.length(),
индекс последнего элемента array.length() - 1;
Если осуществляется попытка выхода за границы массива возникает
исключение ArrayIndexOutOfBoundsException
int[] array = new int[10]// элементы массива, для которых память была
выделена оператором new, будут автоматически инициализированны:
для числовых типов - нулевыми значениями,
для boolean - false,
для ссылочных - null. Массивы распределяются динамически.
Для удаления элемента массива нужно элементу присвоить в зависимости от
типа 0, false, null.
Многомерные массивы это массивы массивов
int[][] array = new int[4][5];
int[][] array = {
 {1, 2, 3, 4},
 {6, 4, 3, 2},
 {23, 4, 5}
 };// длина каждого массива может быть разной - неоднородный массив.
 При резервировании памяти под многомерный массив допускается указание
 только для первого(левого) измерения массива.
 Вторая форма объявления массивов
 int[] array, []array1, []array2;

 19. Арифметические операции.
 Операнды должны иметь числовой тип (byte, short, char, int, long, float, doble).
 Все основные операции воздействуют на числовые типы данных так, как этого
  и следовало ожидать.

  Операция унарного вычитания меняет знак своего единственного операнда,
  операция унарного сложения оставляет знак без изменения.

  Операция деления по модулю.
  а = 25 % 8; //a = 1 возвращает остаток от деления
  а = 42.25 % 10 // a = 2.25
  может выполняться над целочисленными данными и числами с плавающей точкой

  составные операции с присваиванием
  а += 2; дают два преимущества: сокращают объем кода и увеличивают
  эффективность реализации в исполняющей системе.

  инкремент и декремент
  ++а// увеличивает значение операнда на 1
  --a// уменьшает значение операнда на 1

  префиксная форма - значение переменной увеличивается (уменьшается)
  до извлечения значения для применения в выражении.
  а = 1;
  b = ++а// b = 2
  постфиксная форма - предыдущее значение переменной извлекается до
  применения в выражении и только после этого значение операнда
  изменяется.
  а = 1;
  b = а--// b = 1

 20. Поразрядные операции.
 Можно выполнять над целочисленными типами данных:
 byte, short, char, int, long. Данные операции манипулируют
 двоичными разрядами (битами) в целочисленных значениях.
 Все целочисленные типы данных представлены двоичными числами разной,
 длины. Все, кроме char представлены со знаком. Отрицательные числа
 представлены в дополнительном коде путем инвертирования (изменения
 0 на 1, и наоборот), изменения всех двоичных разрядов исходного
 значения и последующего добавления 1 к результату.Также и положительное.
 Причина применения дополнительного кода - процесс перехода через 0.
 byte 0 - 00000000 обратный код 11111111 - отрицательный 0 недопустим
 в целочисленной математике. В этом случае добавляется единица
 100000000 - старший единичный разряд сдвигается влево и теряется. Тем
 самым достигается требуемое поведение, когда 0 и -0 равны.
 а 11111111 равно -1
 Старший двоичный разряд определяет знак целого числа

 ~ НЕ поразрядное отрицание - инвертируются все разряды.
      10101010
     ~01010101

 & И  00101010
    & 00001111
    -----------
      00001010

 | ИЛИ OR
      00101010
    | 00001111
      --------
      00101111

  ^ XOR исключающее ИЛИ
      00101010
    ^ 00001111
      --------
      00100101

   Сдвиг влево <<
   Каждый сдвиг влево на одну позицию удваивает значение.

   Сдвиг вправо >>
   При этом каждый двоичный разряд заполняется своим предыдущим содержимым.
   В итоге сохраняется знак.
   Каждый сдвиг вправо на одну позицию выполняет деление на 2 с
   отбрасыванием остатка.

   Беззнаковый сдвиг вправо >>>
   Всегда вставляет 0 на позиции старшего разряда.

   21. Логические операции.
   & | ^ !
   & | ^ воздействуют также на boolean как на двоичные разряды
   ! инвертирует логическое состояние !false == true

   short-circuit укороченные логические операции
   && и ||
   && если левая часть выражения false, то правая не вычисляется
   || если левая часть выражения true, то правая не вычисляется

22. Тернарная операция
(if-then-else)
int i,k;
k = i < 0 ? -i : i;// если i меньше 0, то к = -1, иначе к = 1


23. Предшествование операций.

expr++ expr--

++expr --expr +expr -expr ~ !

* / %

+ -

<< >> >>>

< > <= >= instanceof

== !=

&

^

|

&&

||

? : (тернарный оператор)

= += -= *= /= %= &= ^= |= <<= >>= >>>= (операторы присваивания)

Чем выше оператор в этой таблице, тем больше его приоритет.
При этом скобки повышают приоритет операции, используемой в выражении.

23. switch
оператор ветвления
int i = 0;
switch(i) {
case 0: System.out.println("i");
break;
case 1: System.out.println("i");
break;
default: System.out.println("0");
}

В отсутствие совпаденией выполняется default.
Параметр switch может быть byte, short, char, int, enum,
String (с JDK 7).

24. Операторы цикла.
while(логическое выражение){тело цикла};
do{тело цикла}while(логическое выражение);

for(int x = 0; x < 5; x++) {блок кода};
for(int x = 0, y = 2; x < y; x++, y--) {блок кода};
for(int x = 0; true; x++) {блок кода};
for( ; ; ) {блок кода};//бесконечный цикл.

for each, начиная с версии JDK5
int[]array = {25, 52, 12, 12, 12};
 for(int x : array) {
 System.out.println(x);
 }
 Итерация в многомерных массивах
 int[][]array = {
 {25, 52, 12, 12, 12},
 {1, 3, 2, 1, 3},
 {5, 59, 2, 1, 12}
 }
 for(int x[] : array) {
 for(int y : x) {
 System.out.println(y);}
}

25. Операторы перехода.
три оператора break, continue, return

break - имеет три пременения:
завершает последовательность операторов case в switch,
для выхода из цикла,
в качестве цивилизованной формы оператора goto.

Когда в теле цикла встречается break, цикл прерывается и управление
передается оператору, следующему за циклом.

оператор break с меткой
break метка:
метка это имя метки, обозначающее блок кода, в итоге выполнение
программы продолжится с конца блока кода, помеченного меткой.
Можно применять для выхода из ряда вложенных блоков, break нельзя
использовать для передачи управления блоку кода, не содержащему оператор
break, но также необязательно для прерывания цикла break должен
находиться в непосредственно объемлющем цикле.
Нельзя выполнить переход к метке если она не определена для объемлющего
блока кода.

continue - продолжение выполнения цикла без безвыполнения остального кода,
следующего за continue.
В цикле while и do while вызывает передачу управления условному выражению
в цикле for управление передается итерационной части цикла, а затем
условному выражению.
Во всех трех случаях любой промежуточный код опускается.

return для выполнения явного выхода из метода и передачи управления объекту,
который вызвал данный метод. Можно использовать в любом месте метода.
В методе main передает управление исполняющей системе Java. Если после return
есть другой код, то return должен предваряться условным выражением if(выражение),
иначе компилятор сигнализирует недостижимый код "unreachable code".


Глава 6. Введение в классы

26. Класс - логическая конструкция, на основе которой построен весь язык Java/
Класс - шаблон для объектов, каркас, определяющий взаимосвязь между его членами,
объект - экземпляр класса.
При определении класса объявляется его форма и сущность. Для этого указываются
данные и код, воздействующий на эти данные.
Хотя очень простые классы могут содержать только данные или только код.
При создании класса создается новый тип данных, который можно использовать
дл создания объектов класса. Создание объекта двухэтапный процесс.
Сначала объявляется переменная типа класса, она лишь ссылается на объект,
но не определяет его. Оператор new динамически (во время выполнения) резервирует
память под объект, и возвращает ссылку на него, эта ссылка присваивается переменной.
Оперативная память динамически выделияется для объектов всех классов.
 На данном этапе эта ссылка содержит просто адрес памяти конкретного объекта.

 27. Методы.
 Метод это набор операторов, сгруппированных для выполнения операции.
 В отношении метода важно различать два термина:
 параметр - это определенная в методе переменная, которая принимает заданное
 значение при вызове метода.
 аргумент - это значение, передаваемое в метод при его вызове.
 Сигнатура метода это его имя и список параметров (и порядок параметров), тип
 возвращаемого значения не входит.
 Если метод не возвращает значение его тип void.
 Если метод возвращает значение, тип данных, возвращаемых методом должен быть
 совместим с возвращаемым типом, указанным в методе, как и переменная,
 принимающая возвращаемое значение.
 Для указания идентификатора метода используется любой допустимый кроме тех,
 которые уже используются другими элементами данного блока кода.

 27. Конструкторы
 Конструктор -  похож на метод, имеющий имя класса, не имеющий возвращаемого значения. Не явно заданным возвращаемым типом
 является тип класса.
 Вызывается автоматически перед окончанием выполнения оператора new.
 Конструктор инициализирует внутреннее состояние объекта, чтобы на выходе был полностью
 инициализированный объект, пригодный к использованию.
 Если конструктор класса не определен явно, то создается конструктор по умолчанию,
 который инициализирует все переменные экземпляра значениями по умолчанию.
 0, null, false. Как только в классе будет определен собственный конструктор,
 конструктор по умолчанию больше не вызывается.
 Конструкторы также могут быть перегружены, как и методы.
 Применение объекта в качестве параметра создает объект копию переданного объекта.


 28. Ключевое слово this.
 Служит ссылкой на объект, для которого был вызван метод, можно пользоваться в теле
 любого метода.

Глава 7. Рассмотрение классов и методов.

 29. Перегрузка методов.
 Два или более методов с одним именем в одном классе и разными параметрами (порядком
 параметров) называются перегруженными.
 При вызове перегружаемого метода, для определения нужного его варианта компилятор
 использует тип и/или количество (или порядок) его аргументов.
 Перегрузка методов - поддерживает полиморфизм, один интерфейс - много методов.
 Автоматическое преобразование типов при вызове метода употребляется если не было
 обнаружено полное соответствие.
 Раннее связывание.

 30. Переопределение методов.
 Если в иерархии классов совпадают имена и сигнатуры суперкласса и его подкласса,
 то метод подкласса переопределяет метод суперкласса.
 Когда такой метод вызывается из своего подкласса, он всегда ссылается на свой
 вариант, скрывая метод суперкласса.
 Если требуется вызвать метод суперкласса, используется слово super.
 Ссылочная переменная суперкласса может ссылаться на объект подкласса, когда
 переопределенный метод вызывается по ссылке на суперкласс, нужный вариант этого
 метода выбирается в зависимости от типа объекта, этот выбор делается в момент
 выполнения.
 Переопределение методов служит основой  динамической диспетчеризации методов.
 Это механизм, с помощью которого вызов переопределенного метода  разрешается
 во время выполнения, а не компиляции.
 Благодаря динамической деспетчеризации
 методов реализуется полиморфизм времени выполнения.
 Это в сочетании с наследованием обеспечивает повторное использование и
 надежность кода.
 Вариант переопределенного метода выбирается в зависимости от типа объекта,
 на который делается ссылка, а не типа ссылочной переменной.
 Позднее связывание.

 31. Передача аргументов.
 Передача по значению(примитивные типы) - в этом случае значение копируется в параметр, не оказывая
 влияния на аргумент.
 Передача по ссылке(ссылочные типы) - в этом случае параметру передается ссылка на аргумент, а
 не его значение, эта ссылка служит для обращения к конкретному аргументу,
 указанному в вызове, это означает, что изменения, вносимые в параметр будут
 влиять на аргумент.

 32.Рекурсия.
  Процесс определения чего либо относительно себя.
  Средство, которое позволяет методу вызывать самого себя.
  Пример вычисление факториала:

  int factorial = 5;

  public int fact (factorial) {
  int result = 0;

  if (factorial == 1) {
  return result;
  }
  result = fact(factorial -1) * factorial
  return result;
  }

 33. Управление доступом.
 Икапсуляция предоставляет управление доступом. Способ доступа определяется
 модификатором доступа.
 public - доступ из любых классов.
 protected - доступ для классов в пакете и классов-наследников.
 без модификатора - по умолчанию - доступ для классов в пакете.
 private  - доступ для членов класса.

 34. Ключевое слово static.
 Член класса объявленный static доступен до создания объектов класса и
 без ссылки на объект.
 Статическими могут быть методы, константы и переменные.
 На статические методы накладывается ряд ограничений:
 они не могут делать ссылки this, suoer
 Они могут вызывать непосредственно только статические методы и переменные
 Если для инициализизации статических переменных необходимо произвести
 вычисления, достаточно объявить статический блок, который будет выполняться
 только один раз при первой загрузке класса.
 static int a = 3;
 static int b;
 static{
 b = a * 4
 }

За пределами класса статическими переменными можно пользоваться
указав имя класса, точку и имя переменной.

35. Ключевое слово final.
Поле объявленное final должно быть инициализированно во время
его объявления и его нельзя изменить, по факту является
константой. Значение такому полю можно присвоить в конструкторе.
final могут быть локальные переменные(нельзя изменить) и
параметры методов(нельзя изменить).
Метод объявленный final нельзя переопределять.
Класс объявленный final нельзя наследовать.
Класс нельзя одноверменно объявлять abstract и final.
Переменные интерфейсов неявно объявлены как final  и static,
их нельзя изменить в классе, реализующем интерфейс.

36. Вложенные и внутренние классы.
Допускается определять один класс в другом.
Это называется вложенный класс.
Вложенный класс является членом внешнего класса.
Можно объявлять классы, являющиеся локальными для блока кода.

Вложенный класс имеет доступ к членам внешнего класса.
Вложенный класс  не имеет доступа к членам вложенного класса.

Два типа вложенных классов:
статический и нестатический.
Нестатический класс называется внутренним - inner.
Внутренний класс имеет доступ ко всем переменным своего и
внешнего класса и может непосредственно ссылаться на них.
Экземпляр внутреннего класса можно создать только в
контексте внешнего

Вложенный (static) класс - nested может обращаться к переменным
своего внешнего класса посредством объекта. В силу этого
ограничения статические классы употребляются редко.


37 Аргументы переменной длины.
Введены в версии JDK5. Variable length arguments -vavarg. Метод, который
принимает переменное количество аргументов, называется методом с аргументами
переменной длины.
static void vaTest(int...v) {}
В этой конструкции компилятору предписывается, что метод может вызываться без
аргументов или с аргументами переменной длины. В итоге массив v неявно объявляется
как int[]. Если аргументы остсутствуют, то длина массива = 0.
Данные методы можно перегружать. Метод может содержать только один vararg,
который должен быть указан последним.
Неоднозначность.
static void vaTest(int x) {}
static void vaTest(int... x) {}
При вызове метода vaTest() компилятор не в состоянии решить какой метод должен
быть вызван.

Глава 8. Наследование.

38.Чтобы унаследовать класс, достаточно ввести определение одного класса в другой
используя слово extends. Наследуемый класс называется суперклассом, наследник -
подклассом. Для каждого подкласса можно указать только один суперкласс. Один
подкласс может быть суперклассом для другого подкласса. Главное преимущество
наследования: суперкласс, определяющий общие свойства ряда объектов, можно
использовать для разработки любого количества специализированных классов. Каждый
подкласс может добавлять собственные особые свойства. В этом сущность наследования.
Подкласс включает все члены суперкласса, за исключением private.
Переменная суперкласса может ссылаться не объект подкласса. Доступные переменные
определяются типом ссылочной переменной, но не типом объекта. Суперклассу неизвестно,
что в него добавляет объект.

Теория ООП выделяет три основных отношения между классами:

Ассоциация
Агрегация и композиция
Обобщение/Расширение (наследование)

Ассоциация
Ассоциация означает, что объекты двух классов могут ссылаться один на другой,
иметь некоторую связь между друг другом.
Например Менеджер может выписать Счет.
Соответственно возникает ассоциация между Менеджером и Счетом.
Ассоциация и есть описание связи между двумя объектами.
Студент учится у Преподавателя. Идея достаточно простая —
два объекта могут быть связаны между собой и это надо как-то описать.

Агрегация и композиция
Агрегация и композиция на самом деле являются частными случаями ассоциации.
Это более конкретизированные отношения между объектами.
Агрегация — отношение когда один объект является частью другого.
Например Студент входит в Группу любителей физики.

Композиция — еще более «жесткое отношение, когда объект не только
является частью другого объекта, но и вообще не может принадлежат
еще кому-то. Например Машина и Двигатель.
Хотя двигатель может быть и без машины,
но он вряд ли сможет быть в двух или трех машинах одновременно.
В отличии от студента, который может входить и в другие группы тоже.
Такие описания всегда несколько условны, но тем не менее.

39. Ключевое слово super.
Иногда приходится создавать суперкласс подробности реализации которого доступны
только ему. В этом случае подкласс не может обратиться непосредственно к закрытым
членам суперкласса или инициализировать их, это можно сделать с помощью ключевого
слова super.
Две общие формы. Одна для вызова конструктора суперкласса, вторая - для обращения
к члену суперкласса.
Конструктор суперкласса должен вызываться первым в теле конструктора подкласса.
В конструкторе подкласса вызывается super() его непосредственного суперкласса.
Конструкторы могут быть перегружаемы, поэтому super можно вызывать, используя
любую форму, определяемую в суперклассе. Конструкторы вызываются в порядке
наследования (иерархия классов). Если super() не вызывается явно, то используется
конструктор по умолчанию  или конструктор без параметров каждого суперкласса.
Вторая форма использования super подобна this, за исключением того, что ссылка
делается на член конкретного непосредственного суперкласса. Эта форма использования
наиболее пригодна, когда член подкласса скрывает член суперкласса с таким же именем.
super.i
Когда подкласс вызывает переопределенный метод, он всегда ссылается на свой вариант.
Если требуется вызвать метод суперкласса, это можно сделать с помощью ключевого слова
super.
show();
super.show();

40. АбстрактныЙ класс VS Интерфейс.
АбстрактныЙ класс - суперкласс, определенный таким образом, чтобы объявить в нем обобщенную форму для
совместного использования всеми его подклассами, не представляя полную реализацию
каждого метода (абстрактные методы - методы под ответственностью подкласса).
Любой класс, содержащий один или более абстрактных методов должен быть объявлен
abstract class. У абстрактного класса не может быть объектов. Это означает, что
абстрактный класс не может быть получен с помощью оператора new.

Нельзя объявлять абстрактные конструкторы и абстрактные статические методы.
У абстрактного класса может быть конструктор, для задания начальных значений
общих переменных вызвать такой конструктор можно при формировании цепочки
конструкторов в подклассе. Если конструктор в абстрактном классе не объявлен
явно, компилятор добавит в абстрактный класс конструктор без параметров
по умолчанию, иначе подкласс не скомпилируется, поскольку первый оператор в
любом конструкторе - неявный вызов конструктора по умолчанию суперкласса.

Любой производный подкласс должен реализовать все абстрактые методы своего суперкласса
или быть объявлен абстрактным. Если этого не сделать это приведет к ошибке
компиляции.

В абстрактные классы может быть включена реализация какого угодно количества
конкретных методов, и может не быть ни одного абстрактного метода.
Абстрактные классы можно применять для создания ссылок на объекты.

Абстрактные классы могут реализовать интерфейсы, но они не обязаны их
реализовывать.

Абстрактные классы не могут быть final. Компилятор выдаст ошибку.

Абстрактные классы могут содержать статические методы (не абстрактные!), но
явление это очень редкое потому, что статические методы невозможно переопределить.

Интерфейс - это контракт в рамках которого разные части программы
взаимодействуют между собой и внешними приложениями.
С помощью ключевого слова interface можно указать, что должен делать класс, но
не как это делать.
Синтаксически интерфейсы аналогичны классам, но не содержат переменные
экземпляра. Могут содержать переменные, которые неявно объявлены final static,
из нельзя изменять в классе, реализующем интерфейс, они должны быть
инициализированы в интерфейсе, данные переменные доступны в классах,
имплементирующих интерфейс.
Один интерфейс может наследовать другой с помощью extends.
 Когда класс наследует другой интерфейс, он должен предоставлять реализацию
 всех методов по цепочке наследования.


Объявление методов интерфейсов, как правило не содержит тела метода.
Чтобы реализовать интерфейс, нужно указать выражение implements (если
класс реализует несколько интерфейсов, то их названия нужно указать через
 запятую) и реализовать полный набор методов (не default!) имплементируемых
 интерфейсов. В каждом классе могут быть определены собственные реализации
 методов. Принцип полиморфизма - один интерфейс, несколько методов. По существу
 методы интерфейса являются абстрактными.

 При наследовании функциональные возможности передаются по иерархии классов вниз -
 расширяются, в результате становятся доступны все большему количеству подклассов,
 Интерфейсы позволяют избежать этой проблемы, они изолируют определение набора
 методов от иерархии наследования и классы, не связанные между собой иерархически,
 могут реализовать один и тот же интерфейс.

 Интерфейс может быть:
 - public, тогда он должен быть единственным открытым интерфейсом в файле, имя
 файла должно совпадать с интерфейсом.

 - по умолчанию, без модификатора, в этом случае он доступен только
 классам его пакета.

 В JDK8 введены методы(метод расширения) с модификатором default,
 с реализацией по умолчанию. Это средство, позволяющее расширять интерфейсы,
 не нарушая существующий код (данные методы не обязательно, но возможно
 реализовывать в классах). Введены статические методы. Для вызова такого метода
 не требуется реализация в классе, ни экземпляр, достаточно указать имя
 интерфейса и через точку имя метода.
 Статические методы интерфейса не наследуются.

 Правила множественного наследования.
 В случае возникновения конфликта имен
 приоритет одается его реализации в классе.
 Если наследуются два интерфейса с одинаковым методом по умолчанию, ни один
 из которых не переопределяется в классе, возникает ошибка.
 Когда один интерфейс наследует другой и оба определяют метод по умолчанию,
 предпочтение одается наследующему интерфейсу.
 Однако используя super. можно вызвать реализацию по умолчанию наследуемого
 интерфейса.
 Если в классе реализуется два интерфейся с одинаковым методом, то этот метод
 может использоваться клиентами любого из двух интерфейсов.
 Методы, реализующие методы интерфейса, должны быть объявлены как public.
 Сигнатура метода класса и соответствующего методв интерфейса должна совпадать.


 Интерфейс может быть членом класса или другого интерфейся, тогда он может
 иметь модификатор доступа public, private, protected.
 Если интерфейс используется за пределами объемлющей его области
 действия, его имя должно быть уточнено именем класса или интерфейса, членом
 которого он является.

 Если класс имплементирует интерфейс, но не полностью реализует его, он
 должен быть объявлен как абстрактный.

41. Класс Object.

package java.lang;

public class Object {

*********************************************************
 1.   public final native Class<?> getClass();
*********************************************************
// getClass() возвращает ссылку на класс в runtime.
// С его помощью можно получать информацию о классе,
// к которому принадлежит объект.

***************************************************************
    protected void finalize() throws Throwable { }
***************************************************************
Метод, который будет вызываться непосредственно перед окончательным
уничтожением объекта сборщиком мусора. (финализатором).
В Java finalize() может быть использован для обеспечения чистого завершения
объекта. К примеру, мы можете использовать finalize() чтобы
удостовериться в том, что открытый файл, принадлежащий данному объекту,
был закрыт. Для добавления финализатора в класс, вам просто следует
определить метод finalize() в Java. Среда выполнения Java производит
вызов данного метода непосредственно перед обработкой объекта данного класса.
В составе метода finalize(), вы указываете те действия,
которые должны быть выполнены перед уничтожением объекта.
Ключевое слово protected представляет спецификатор,
предотвращающий доступ к finalize() посредством кода,
определяемого вне его класса.
Это свидетельствует о том, что вы не можете знать как или
даже когда будет производиться выполнение finalize(). К примеру,
если ваша программа будет окончена до «сборки мусора»,
finalize() не будет выполняться.



*******************************************************************************
 2.   protected native Object clone() throws CloneNotSupportedException;
******************************************************************************
// https://habr.com/ru/post/246993/
// Иногда необходимо получить копию объекта, которая не зависела бы
// от оригинала. С которой можно было бы производить манипуляции,
// при этом, не изменяя оригинал. При обыкновенном присваивание объектов
// (obj1 = obj2;) передаются ссылки на объект. В итоге два экземпляра ссылаются
// на один объект, и изменение одного приведет к изменению другого.
// нам на помощь придет интерфейс Cloneable и метод clone() класса Object.
//если нам необходимо получить независимый клон объекта,
// то необходимо вызвать метод clone().
// Данный метод объявлен, как protected, а это значит, что метод защищен,
// и может быть доступен только при наследовании объекта.
// Как выясняется, это не является проблемой, потому как любой класс,
// является потомком класса Object. Однако при защищенном методе
// класс может клонировать только свои собственные объекты.
// Чтобы клонировать другие объекты,
// метод clone() необходимо расширить до public.
// public User clone() throws CloneNotSupportedException {
                return (User)super.clone();}
// Как мы можем видеть метод clone() может выбрасывать исключение
// CloneNotSupportedException. Данное исключение возникает в случае,
// когда клонируемый класс не имеет реализации интерфейса Cloneable.
// Интерфейс Cloneable не реализует ни одного метода.
// Он является всего лишь маркером, говорящим, что данный класс
// реализует клонирование объекта. Само клонирование осуществляется вызовом
// родительского метода clone().
// Данный вид клонирования называется поверхностным клонированием.
// Его можно использовать только в том случае,
// если у клонируемого класса объявлены  неизменяемые поля-примитивы.
// Существует так же второй вид клонирования объекта,
// который называется глубокое клонирование. Его используют в тех случаях,
// когда в клонируемом классе есть изменяемые объекты (ссылки).
// public User clone() throws CloneNotSupportedException {
                User clone = (User)super.clone();
                clone.birthday = (GregorianCalendar) birthday.clone();
                return clone;}
// clone.birthday = (GregorianCalendar) birthday.clone();
// напрямую клонируется поле birthday

По соглашению, метод clone() должен возвращать объект независимый
от клонируемого объекта, но механизм работы метода clone() класса Object
не предоставляет возможности получить полностью клонированый обьект
для любого класса. Он возвращает лишь поверхностную копию, а далее,
работа по глубокому клонированию возлагается на разработчика.
Проще говоря, если у "оригинала" есть поле которое содержит ссылку
на какой-то обьект, то и поле клона будет ссылаться на тот же обьект,
а это противоречит соглашению о независимости клонируемых обьектов.
В таком случае, необходимо для всех изменяемых обьектов либо вызывать clone() (если это возможно) либо создавать новые с таким же сосотянием. И, насколько я понимаю, чтобы избежать "слепое клонирование" авторами языка были введены следующие ограничения:
 - метод clone() обьявлен как protected (исключает возможность вызова
 прямо на обьекте)
 - клонируемый класс должен реализовывать интерфейс Cloneable
Интерфейс Cloneable не содержит в себе ни одного метода и
является по сути "маркером" того, что обьект может быть клонирован,
без него, при попытке клонирования будет выброшен CloneNotSupportedException.
Перед тем как обьявлять свой класс как Cloneable, следует внимательно
проанализировать его структуру, и определить какие поля нужно
проинициализировать после выполнения super.clone().



******************************************************************************
3.    public native int hashCode();
******************************************************************************
public static void main(String[] args) {
		Object object = new Object();
		int hCode;
		hCode = object.hashCode();
		System.out.println(hCode);
	}

	1389133897 - пример вывода int
	function от hash — «превращать в фарш», «мешанина»[1]),
	или функция свёртки — функция, осуществляющая преобразование массива
	входных данных произвольной длины в (выходную) битовую строку
	установленной длины, выполняемое определённым алгоритмом.
	хеш-код это число, у которого есть свой предел,
	который для java ограничен примитивным целочисленным типом int
	от -2_147_483_648 до 2_147_483_647
	В итоге, в терминах Java, хеш-код — это целочисленный
	результат работы метода, которому в качестве входного параметра
	передан объект. хеш-код вычисляется на основании содержимого объекта (значения полей)
	Хэш-кодом называется условно уникальный числовой идентификатор,
	сопоставляемый какому-либо элементу. Из соображений безопасности выдавать адрес объекта
	прикладной программе нельзя. Поэтому в Java хэш-код заменяет адрес объекта в тех случаях,
	когда для каких-либо целей надо хранить таблицы адресов объектов.
	Здесь главное понять, что:
    Если хеш-коды разные, то и входные объекты гарантированно разные.
    Если хеш-коды равны, то входные объекты не всегда равны.

    Ситуация, когда у разных объектов одинаковые хеш-коды называется
    — коллизией. Вероятность возникновения коллизии
    зависит от используемого алгоритма генерации хеш-кода.
    Хеш-код это число, идентифицирующее обьект,
    поэтому при вычислении хеш-кода следует выбирать уникальные
    и не изменяющиеся во время жизни обьекта поля

    Переопределение метода
    @Override
    	public int hashCode() {
    		final int prime = 31;
    		int result = 1;
    		result = prime * result + varA;
    		result = prime * result + varB;
    		return result;
    	}

Встроенный хеш-код генерируется лишь один раз для каждого объекта
при первом вызове метода hashCode(), после чего сохраняется в
заголовке объекта для последующих вызовов. Но для первого раза
используется именно random! Убедитесь сами,
заглянув в исходники OpenJDK (функция get_next_hash).

****************************************************************************
    public boolean equals(Object obj) {
        return (this == obj);
    }
****************************************************************************
При сравнение объектов, операция “==” вернет true лишь в одном случае
— когда ссылки указывают на один и тот-же объект.
В данном случае не учитывается содержимое полей.
Указывает, равен ли какой-либо другой объект этому объекту.

Метод equals реализует отношение эквивалентности для ненулевых ссылок на объекты:

Оно рефлексивно: для любого ненулевого ссылочного значения x, x.equals(x) должно возвращать true.
Оно симметрично: для любых ненулевых ссылочных значений x и y x.equals(y) должен возвращать true,
только если y.equals(x) возвращает true.
Оно транзитивно: для любых ненулевых ссылочных значений x, y и z, если x.equals(y) возвращает true,
а y.equals(z) возвращает true, тогда x.equals(z) должен возвращать true.
Оно непротиворечиво (консистентно): для любых ненулевых ссылочных значений x и y
множественные вызовы x.equals(y) последовательно возвращают true или последовательно
возвращают false при условии, что никакая информация, используемая в сравнениях equals на объектах,
не изменяется.
Для любого ненулевого ссылочного значения x, x.equals(null) должен возвращать false.
Необходимо переопределять метод hashCode всякий раз, когда метод equals переопределяется,
чтобы поддерживать общий контракт для метода hashCode,
в котором говорится, что равные объекты должны иметь одинаковые хэш-коды.
 public boolean equals(Object obj) {// class Man - example
        if (this == obj) return true;
        if (obj == null || obj.getClass() != getClass()) return false;
        Man man == (Man)obj;
        return dnaCode == man.dnaCode;
    }

****************************************************************************
    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
 ***************************************************************************
Возвращает строковое представление объекта.
В общем случае метод toString возвращает строку, которая является
"текстовым представлением" этого объекта. Результатом должно быть краткое,
но информативное представление, которое легко читается человеком. Рекомендуется,
чтобы все подклассы переопределяли этот метод.
Метод toString для класса Object возвращает строку, состоящую из имени класса,
экземпляром которого является объект, символа знака "@" и
шестнадцатеричного представления без знака хэш-кода объекта.
Другими словами, этот метод возвращает строку, равную значению:

getClass().getName() + '@' + Integer.toHexString(hashCode())
Java Object.toString ()также использует шестнадцатеричное представление
того, что фактически является его хэш-кодом идентичности .
В большинстве стандартных классов этот метод переопределен.
Для числовых классов возвращается строковое представление числа,
для строковых – содержимое строки,
для символьного – сам символ (а не строковое представление его кода!).




****************************************************************************************
    private static native void registerNatives();
******************************************************************************
        static {
            registerNatives();
        }

    public final native void notify();

    public final native void notifyAll();

    public final native void wait(long timeout) throws InterruptedException;

    public final void wait(long timeout, int nanos) throws InterruptedException {
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }

        if (nanos >= 500000 || (nanos != 0 && timeout == 0)) {
            timeout++;
        }

        wait(timeout);
    }

    public final void wait() throws InterruptedException {
        wait(0);
    }


}













-------------------------------------------------------------
Методы класса Object

1. public final native Object getClass
возвращает класс объекта в runtime

2. protected void finalize()
Вызывает сборщик мусора, когда не осталось ссылок на данный объект.
в теле метода указываются действия, которые необходимо выполнить
перед удалением объекта.
Если программа была закончена до начала работы сборщика мусора, то
метод не выполнится ни разу.
В Java освобождение памяти осуществляется автоматически Garbage Collector.
Можно вызвать метод System.gc() но система сама решит исполнять ли этот
запрос.
Метод finalize() не вызывается при выходе объекта из области действия.
Начиная с JDK9 метод не рекомендуется к использованию.

3.protected native Object clone()
Возвращает поверхностную копию объекта, копируя поля примитивных типов,
и ссылку на тот же самый ссылочный объект.
Бросает исключение CloneNotSupportExcepcion, если класс не имплементировал
интерфейс Cloneable (интерфейс-маркер, не содержащий ни одного метода).
Для более глубокого клонирования необходимо переопределение метода.
Для этого вызывается метод суперкласса clone() и копируются поля объекта
примитивных типов
User clone = (User)super.clone();
Если объект содержит поле ссылочного типа, это поле клонируется отдельно.
clone.Birthday = (GregorianCalendar)birthday.clone();
return clone;
Должны выполнятся условия:
x.clone() != x;
x.clone().getClass() = x.getClass();
x.clone.equals(x) == true;

4. public boolean equals(Object o) {
    return (this == o);
}
Метод по умолчанию возвращает true если обе ссылки указывают
на один и тот же объект.
Если необходимо сравнить разные объекты одного типа, метод необходимо
переопределить с учетом его полей.
на примере Blackbox

class BlackBox {
int a;
int b;

Blackbox(int a, int b) {
this.a = a;
this.b = b;
}

public boolean equals (Object o) {
 // сначала выясняем, если это один и тот же объект
 if(this == o) return true;
 // если объект равен null или принадлежит другому классу
 if(o == null || this.getClass() != o.getClass()) return false;
 // тогда приводим его к типу нашего объекта и сравниваем их поля
 BlackBox box = (BlackBox) o;
 if(a == box.a && b == box.b) return true;
 else return false;
}

Переопределенный метод equals должен удовлетворять требованиям:
1. рефлексивность - объект должен быть равен сам себе
x.equals(x)
2. симметричность
a.equals(b) то и b.equals(a)
3. транзитивность - если два объекта равны третьему, то они равны
a.equals(z) и b.equals(z) то и   a.equals(b)
4. постоянство - результаты equals() должны меняться только при изменении
входящих в объекты полей, если поля не изменялись результат тот же.
5. неравенство с null
a.equals(null) == false;
 }


5. public native int hashCode()
hashcode в основу работы алгоритма положен генератор случайных чисел,
поэтому при каждом запуске программы у объекта будет разный хэшкод.
Диапазон хэшкодов ограничен диапазоном числа int -2147482648 до +2147483657
Поскольку объектов может быть больше данного диапазона, может возникать
коллизия - у разных объектов могут быть одинаковые коды.
Должны выполняться правила
Но если объекты одинаковые, то их хэшкоды должны быть одинаковы.
Каждый раз при вычислении с переопределенным hashCode() на одном и том же
объекте должен быть одинаковый хэшкод.

При переопределении метода equals выделяюся значимые поля для сравнения,
поэтому следует также обязательно переопределить метод hashCode();

public native int hashCode() {
// определяем нечетное число 31 или 29
final int prime = 31;
int result= 0;
//вычисляем хэшкод с учетом полей объекта
result = prime * result + a;
result = prime * result + b;
return result;

}


6. public String toString() {
return getClass().getName() + "&" + Integer.toHexString(hashCode());

}
// Для Object.toString() возвращается шестнадцатеричное представление
того, что фактически является его хэшкодом.
В большинстве старндартных классов этот метод переопределен
Для числовых типов возвращает строковое представление числа
Для строк - строковое представление
Для символов - символ.


